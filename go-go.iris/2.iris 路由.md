### iris 路由

1. 行为
    1. Iris 的默认行为是接受和注册像 /api/user 这类路径的路由，而且路径末端不带斜杠。如果客户端尝试访问 $your_host/api/user/ ，则 Iris 路由器将自动将其重定向到 $your_host/api/user，以便由注册路由处理它
    2. 对请求的资源 禁用路径校正， 你可以传递 iris 配置的 iris.WithoutPathCorrection 选项到 app.Run 函数
    ```
    app.Run(iris.Addr(":8080"), iris.WithoutPathCorrection)
    ```
    3. 想为/api/user 和 /api/user/路径，保持相同的处理程序和路由而无需重定向(常见情况) ，那么仅仅使用 iris.WithoutPathCorrectionRedirection 选项
    ```
    app.Run(iris.Addr(":8080"), iris.WithoutPathCorrectionRedirection)
    ```
2. API
    1. 所有的 HTTP 方法都是被支持的，开发者也可以在相同的路径上注册不同的方法
        - 第一个参数是 HTTP 方法，第二个参数是路由的请求路径，第三个可变参数应包含一个或多个 iris.Handler，当客户端从客户端请求该特定资源路径时，这些 iris.Handler 将按照注册顺序执行
        ```
        app := iris.New()
        app.Handle("GET", "/hello", func(ctx iris.Context) {
            ctx.HTML("<h1> hello world </h1>")
        })
        ```
    2.  iris 为所有 HTTP 方法提供了辅助方法。 第一个参数是路由的请求路径，第二个参数应包含一个或多个 iris.Handler，当用户从服务器请求该特定资源路径时，这些 iris.Handler 将会按照注册顺序执行
        ```
        app := iris.New()

        // 方法: "GET"
        app.Get("/", handler)

        // 方法: "POST"
        app.Post("/", handler)

        // 方法: "PUT"
        app.Put("/", handler)

        // 方法: "DELETE"
        app.Delete("/", handler)

        // 方法: "OPTIONS"
        app.Options("/", handler)

        // 方法: "TRACE"
        app.Trace("/", handler)

        // 方法: "CONNECT"
        app.Connect("/", handler)

        // 方法: "HEAD"
        app.Head("/", handler)

        // 方法: "PATCH"
        app.Patch("/", handler)

        // 注册支持所有 HTTP 方法的路由
        app.Any("/", handler)

        func handler(ctx iris.Context){
            ctx.Writef("Hello from method: %s and path: %s\n", ctx.Method(), ctx.Path())
        }
        ```
3. 离线路由
    1. None 可以用它对外部隐藏一个路由， 但是你却可以通过 Context.Exec 方法从其他路由处理程序中调用它。每个 API 处理方法都会返回路由的 值。路由的 IsOnline 方法报告该路由的当前状态。你可以通过路由 Route.Method 字段的值，将路由的状态从离线改变在线。 当然，在服务时路由器的每次更改都需要一个app.RefreshRouter() 调用
    ```
    app := iris.New()

    none := app.None("/invisible/{username}", func(ctx iris.Context) {
        ctx.Writef("Hello %s with method: %s", ctx.Params().Get("username"), ctx.Method())

        if from := ctx.Values().GetString("from"); from != "" {
            ctx.Writef("\nI see that you're coming from %s", from)
        }
    })

    app.Get("/change", func(ctx iris.Context) {
        if none.IsOnline() {
            none.Method = iris.MethodNone
        } else {
            none.Method = iris.MethodGet
        }

        //刷新服务中重建的路由器，以便
        // 收到新路线通知。
        app.RefreshRouter()
    })

    app.Get("/execute", func(ctx iris.Context) {
        if !none.IsOnline() {
            ctx.Values().Set("from", "/execute with offline access")
            ctx.Exec("NONE", "/invisible/iris")
            return
        }

        // 与导航到 "http://localhost:8080/invisible/iris" 相同
        // 当 /change 被调用并且路由状态从
        // "离线" 改变为 "在线"
        ctx.Values().Set("from", "/execute")
        // 值和 session 可以被共享，
        // 当调用 Exec 从一个"外部"的 Context。
        // 	ctx.Exec("NONE", "/invisible/iris")
        // 或者在 "/change" 之后：
        ctx.Exec("GET", "/invisible/iris")
    })
    ```
4. 路由分组
    1. 被路径前缀分组的一组路由可以(可选)共享相同的中间件处理程序和模板布局。 一个组同时也可以有一个嵌套组
    2. .Party 用于对路由进行分组，开发人员可以声明无限数量的(嵌套)组
    ```
    app := iris.New()

    users := app.Party("/users", myMiddleware)

    // http://localhost:8080/users/1/profile
    users.Get("/{id:uint64}/profile", userProfileHandler)
    // http://localhost:8080/users/messages/1
    users.Get("/messages/{id:uint64}", userMessageHandler)
    ```
    3. 使用 PartyFunc 函数编写相同的方法，该方法接受子路由器(当前分组的子路由器)
    ```
    app := iris.New()

    app.PartyFunc("/users", func(users iris.Party) {
        users.Use(myMiddleware)

        // http://localhost:8080/users/1/profile
        users.Get("/{id:uint64}/profile", userProfileHandler)
        // http://localhost:8080/users/messages/1
        users.Get("/messages/{id:uint64}", userMessageHandler)
    })
    ```
5. 路径参数。Iris 的路由器可以处理不同种类的路由而不会发生冲突
    ```
    app := iris.Default()
    // 匹配所有以 "/user/" 为前缀的 GET 请求，后跟随单个路径部分，:string为类型限定
    app.Get("/user/{name:string}", func(ctx iris.Context) {
		name := ctx.Params().Get("name")
		ctx.JSON(iris.Map{
			"name": name,
		})
	})
	// 匹配所有包含 "/assets/**/*" 前缀的 GET 请求， 它是一个 ctx.Params().Get("asset") 的通配符，等同于任何跟随在 /assets/之后的路径
	app.Get("/assets/{asset:path}", func(ctx iris.Context) {
		ctx.JSON(ctx.Params().Get("asset"))
	})
    // 匹配所有以 /user/ 为前缀的GET请求，后跟一个等于或大于 1 的数字
    app.Get("/user/{userid:int min(1)}", func(ctx iris.Context) {
		id := ctx.Params().Get("userid")
		ctx.JSON(iris.Map{
			"id": id,
		})
	})
    // 匹配除其他路由已处理的请求之外的所有 GET 请求
    app.Get("{root:path}", func(ctx iris.Context) {
        root := ctx.Params().Get("root")
		ctx.JSON(iris.Map{
			"root": root,
		})
    })
    ```
6. 路径参数类型
    1. 路径参数的名称应只能包含字母。不允许使用数字或符号，例如 "_"
    2. 内置的可用参数类型
    
    参数类型	|Go 类型	|验证	|获取的辅助方法
    --- | --- | --- | ---
    :string|	string|	任何内容（单路径）|	Params().Get
    :int|	int|	-9223372036854775808 to 9223372036854775807 (x64) or -2147483648 to 2147483647 (x32), depends on the host arch|	Params().GetInt
    :int8|	int8|	-128 to 127|	Params().GetInt8
    :int16|	int16|	-32768 to 32767|	Params().GetInt16
    :int32|	int32|	-2147483648 to 2147483647|	Params().GetInt32
    :int64|	int64|	-9223372036854775808 to 9223372036854775807|	Params().GetInt64
    :uint|	uint|	0 to 18446744073709551615 (x64) or 0 to 4294967295 (x32), depends on the host arch|	Params().GetUint
    :uint8|	uint8|	0 to 255|	Params().GetUint8
    :uint16|	uint16|	0 to 65535|	Params().GetUint16
    :uint32|	uint32|	0 to 4294967295|	Params().GetUint32
    :uint64|	uint64|	0 to 18446744073709551615	|Params().GetUint64
    :bool|	bool|	"1" or "t" or "T" or "TRUE" or "true" or "True" or "0" or "f" or "F" or "FALSE" or "false" or "False"|	Params().GetBool
    :alphabetical|	string|	小写或大写字母|	Params().Get
    :file|	string|	小写或大写字母、数字、下划线 （*）、破折号 （-）、点 （.） 和空格或其他对文件名无效的特殊字符	|Params().Get
    :path|	string|	任何内容，都可以由斜杠（路径段）分隔，但应该是路径的最后一部分	|Params().Get

    ```
    app.Get("/users/{id:uint64}", func(ctx iris.Context){
        id := ctx.Params().GetUint64Default("id", 0)
        // [...]
    })
    ```
    3. 内置方法

    内置方法|	参数类型
    --- | ---
    regexp(expr string)|	:string
    prefix(prefix string)|	:string
    suffix(suffix string)|	:string
    contains(s string)|	:string
    min(minValue int or int8 or int16 or int32 or int64 or uint8 or uint16 or uint32 or uint64 or float32 or float64)|	:string(char length), :int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64
    max(maxValue int or int8 or int16 or int32 or int64 or uint8 or uint16 or uint32 or uint64 or float32 or float64)|	:string(char length), :int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64
    range(minValue, maxValue int or int8 or int16 or int32 or int64 or uint8 or uint16 or uint32 or uint64 or float32 or float64)|	:int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64

    ```
    app.Get("/profile/{name:alphabetical max(255)}", func(ctx iris.Context){
        name := ctx.Params().Get("name")
        // len(name) <=255 否则这个路由将触发 404 Not Found
        // ，此处理程序将不会执行。
    })
    ```
7. 路由中间件
    1. 编写中间件
        - 中间件只是func(ctx iris.Context)的处理程序形式之一，当上一个中间件调用ctx.Next() 时，当前中间件就会执行
    ```
    func before(ctx iris.Context) {
        requestPath := ctx.Path()
        println("Before the mainHandler: " + requestPath)

        ctx.Values().Set("info", requestPath)
        ctx.Next() //执行下一个处理程序，在本例中为主要处理程序。
    }

    func after(ctx iris.Context) {
        println("After the mainHandler")
    }

    func indexHandler(ctx iris.Context) {
        ctx.JSON(iris.Map{
            "message": "hello",
        })
    }

    func mainHandler(ctx iris.Context) {
        println("Inside mainHandler")

        // 从 "before" 处理程序中获取信息。
        info := ctx.Values().GetString("info")

        // 向客户端写一些内容作为响应。
        ctx.HTML("<h1>Response</h1>")
        ctx.HTML("<br/> Info: " + info)

        ctx.Next() // 执行 "after" 中间件
    }
    ```
    2. 使用路由中间件
        - Use 和 Done 应用于当前路由分组和它的子分组，即在调用 Use 或 Done 之前的路由，不会应用该中间件
    ```
    func main() {
        app := iris.New()
        app.Get("/home", indexHandler)
        app.Use(before)
        app.Done(after)
        // app.Use(before) 和 app.Done(after) 或者 app.Get("/", before, mainHandler, after)
        app.Get("/main", mainHandler)
        app.Run(iris.Addr(":8080"))
    }
    ```
    3. 使用全局路由中间件
        - 在路由注册前使用 `app.Use/Done，使用 UseGlobal/DoneGlobal
    ```
    func main() {
        app := iris.New()
        app.Get("/home", indexHandler)
        app.UseGlobal(before)
        app.DoneGlobal(after)
        // app.Use(before) 和 app.Done(after) 或者 app.Get("/", before, mainHandler, after)
        app.Get("/main", mainHandler)
        app.Run(iris.Addr(":8080"))
    }
    ```
    4. 使用 ExecutionRules 去强制执行完成的处理程序，而不需要使用ctx.Next()
    ```
    app.SetExecutionRules(iris.ExecutionRules{
        // Begin: ...
        // Main:  ...
        Done: iris.ExecutionOptions{Force: true},
    })
    ```
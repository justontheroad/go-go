### iris 路由

1. 行为
    1. Iris 的默认行为是接受和注册像 /api/user 这类路径的路由，而且路径末端不带斜杠。如果客户端尝试访问 $your_host/api/user/ ，则 Iris 路由器将自动将其重定向到 $your_host/api/user，以便由注册路由处理它
    2. 对请求的资源 禁用路径校正， 你可以传递 iris 配置的 iris.WithoutPathCorrection 选项到 app.Run 函数
        ```
        app.Run(iris.Addr(":8080"), iris.WithoutPathCorrection)
        ```
    3. 想为/api/user 和 /api/user/路径，保持相同的处理程序和路由而无需重定向(常见情况) ，那么仅仅使用 iris.WithoutPathCorrectionRedirection 选项
        ```
        app.Run(iris.Addr(":8080"), iris.WithoutPathCorrectionRedirection)
        ```
    4. EnablePathIntelligence 选项，可以传递给app.Run/Listen方法来自动重定向一个没有找到的路径到它最接近的匹配路径。e.g "http://localhost:8080/contac" to "http://localhost:8080/contact"
        ```
        app.Listen(":8080", iris.WithPathIntelligence)
        ```
    5. 通过设置ForceLowercaseRouting选项强制所有路径小写
        ```
        app.Listen(":8080", iris.WithLowercaseRouting, iris.WithPathIntelligence)
        ```
2. API
    1. 所有的 HTTP 方法都是被支持的，开发者也可以在相同的路径上注册不同的方法
        - 第一个参数是 HTTP 方法，第二个参数是路由的请求路径，第三个可变参数应包含一个或多个 iris.Handler，当客户端从客户端请求该特定资源路径时，这些 iris.Handler 将按照注册顺序执行
        ```
        app := iris.New()
        app.Handle("GET", "/hello", func(ctx iris.Context) {
            ctx.HTML("<h1> hello world </h1>")
        })
        ```
    2.  iris 为所有 HTTP 方法提供了辅助方法。 第一个参数是路由的请求路径，第二个参数应包含一个或多个 iris.Handler，当用户从服务器请求该特定资源路径时，这些 iris.Handler 将会按照注册顺序执行
        ```
        app := iris.New()

        // 方法: "GET"
        app.Get("/", handler)

        // 方法: "POST"
        app.Post("/", handler)

        // 方法: "PUT"
        app.Put("/", handler)

        // 方法: "DELETE"
        app.Delete("/", handler)

        // 方法: "OPTIONS"
        app.Options("/", handler)

        // 方法: "TRACE"
        app.Trace("/", handler)

        // 方法: "CONNECT"
        app.Connect("/", handler)

        // 方法: "HEAD"
        app.Head("/", handler)

        // 方法: "PATCH"
        app.Patch("/", handler)

        // 注册支持所有 HTTP 方法的路由
        app.Any("/", handler)

        func handler(ctx iris.Context){
            ctx.Writef("Hello from method: %s and path: %s\n", ctx.Method(), ctx.Path())
        }
        ```
3. 离线路由
    1. None 可以用它对外部隐藏一个路由， 但是你却可以通过 Context.Exec 方法从其他路由处理程序中调用它。每个 API 处理方法都会返回路由的 值。路由的 IsOnline 方法报告该路由的当前状态。你可以通过路由 Route.Method 字段的值，将路由的状态从离线改变在线。 当然，在服务时路由器的每次更改都需要一个app.RefreshRouter() 调用
        ```
        app := iris.New()

        none := app.None("/invisible/{username}", func(ctx iris.Context) {
            ctx.Writef("Hello %s with method: %s", ctx.Params().Get("username"), ctx.Method())

            if from := ctx.Values().GetString("from"); from != "" {
                ctx.Writef("\nI see that you're coming from %s", from)
            }
        })

        app.Get("/change", func(ctx iris.Context) {
            if none.IsOnline() {
                none.Method = iris.MethodNone
            } else {
                none.Method = iris.MethodGet
            }

            //刷新服务中重建的路由器，以便
            // 收到新路线通知。
            app.RefreshRouter()
        })

        app.Get("/execute", func(ctx iris.Context) {
            if !none.IsOnline() {
                ctx.Values().Set("from", "/execute with offline access")
                ctx.Exec("NONE", "/invisible/iris")
                return
            }

            // 与导航到 "http://localhost:8080/invisible/iris" 相同
            // 当 /change 被调用并且路由状态从
            // "离线" 改变为 "在线"
            ctx.Values().Set("from", "/execute")
            // 值和 session 可以被共享，
            // 当调用 Exec 从一个"外部"的 Context。
            // 	ctx.Exec("NONE", "/invisible/iris")
            // 或者在 "/change" 之后：
            ctx.Exec("GET", "/invisible/iris")
        })
        ```
4. 路由分组
    1. 被路径前缀分组的一组路由可以(可选)共享相同的中间件处理程序和模板布局。 一个组同时也可以有一个嵌套组
    2. .Party 用于对路由进行分组，开发人员可以声明无限数量的(嵌套)组
        ```
        app := iris.New()

        users := app.Party("/users", myMiddleware)

        // http://localhost:8080/users/1/profile
        users.Get("/{id:uint64}/profile", userProfileHandler)
        // http://localhost:8080/users/messages/1
        users.Get("/messages/{id:uint64}", userMessageHandler)
        ```
    3. 使用 PartyFunc 函数编写相同的方法，该方法接受子路由器(当前分组的子路由器)
        ```
        app := iris.New()

        app.PartyFunc("/users", func(users iris.Party) {
            users.Use(myMiddleware)

            // http://localhost:8080/users/1/profile
            users.Get("/{id:uint64}/profile", userProfileHandler)
            // http://localhost:8080/users/messages/1
            users.Get("/messages/{id:uint64}", userMessageHandler)
        })
        ```
5. 路径参数。Iris 的路由器可以处理不同种类的路由而不会发生冲突
    ```
    app := iris.Default()
    // 匹配所有以 "/user/" 为前缀的 GET 请求，后跟随单个路径部分，:string为类型限定
    app.Get("/user/{name:string}", func(ctx iris.Context) {
		name := ctx.Params().Get("name")
		ctx.JSON(iris.Map{
			"name": name,
		})
	})
	// 匹配所有包含 "/assets/**/*" 前缀的 GET 请求， 它是一个 ctx.Params().Get("asset") 的通配符，等同于任何跟随在 /assets/之后的路径
	app.Get("/assets/{asset:path}", func(ctx iris.Context) {
		ctx.JSON(ctx.Params().Get("asset"))
	})
    // 匹配所有以 /user/ 为前缀的GET请求，后跟一个等于或大于 1 的数字
    app.Get("/user/{userid:int min(1)}", func(ctx iris.Context) {
		id := ctx.Params().Get("userid")
		ctx.JSON(iris.Map{
			"id": id,
		})
	})
    // 匹配除其他路由已处理的请求之外的所有 GET 请求
    app.Get("{root:path}", func(ctx iris.Context) {
        root := ctx.Params().Get("root")
		ctx.JSON(iris.Map{
			"root": root,
		})
    })
    ```
6. 路径参数类型
    1. 路径参数的名称应只能包含字母。不允许使用数字或符号，例如 "_"
    2. 内置的可用参数类型
    
    参数类型	|Go 类型	|验证	|获取的辅助方法
    --- | --- | --- | ---
    :string|	string|	任何内容（单路径）|	Params().Get
    :int|	int|	-9223372036854775808 to 9223372036854775807 (x64) or -2147483648 to 2147483647 (x32), depends on the host arch|	Params().GetInt
    :int8|	int8|	-128 to 127|	Params().GetInt8
    :int16|	int16|	-32768 to 32767|	Params().GetInt16
    :int32|	int32|	-2147483648 to 2147483647|	Params().GetInt32
    :int64|	int64|	-9223372036854775808 to 9223372036854775807|	Params().GetInt64
    :uint|	uint|	0 to 18446744073709551615 (x64) or 0 to 4294967295 (x32), depends on the host arch|	Params().GetUint
    :uint8|	uint8|	0 to 255|	Params().GetUint8
    :uint16|	uint16|	0 to 65535|	Params().GetUint16
    :uint32|	uint32|	0 to 4294967295|	Params().GetUint32
    :uint64|	uint64|	0 to 18446744073709551615	|Params().GetUint64
    :bool|	bool|	"1" or "t" or "T" or "TRUE" or "true" or "True" or "0" or "f" or "F" or "FALSE" or "false" or "False"|	Params().GetBool
    :alphabetical|	string|	小写或大写字母|	Params().Get
    :file|	string|	小写或大写字母、数字、下划线 （*）、破折号 （-）、点 （.） 和空格或其他对文件名无效的特殊字符	|Params().Get
    :path|	string|	任何内容，都可以由斜杠（路径段）分隔，但应该是路径的最后一部分	|Params().Get

    ```
    app.Get("/users/{id:uint64}", func(ctx iris.Context){
        id := ctx.Params().GetUint64Default("id", 0)
        // [...]
    })
    ```
    3. 内置方法

    内置方法|	参数类型
    --- | ---
    regexp(expr string)|	:string
    prefix(prefix string)|	:string
    suffix(suffix string)|	:string
    contains(s string)|	:string
    min(minValue int or int8 or int16 or int32 or int64 or uint8 or uint16 or uint32 or uint64 or float32 or float64)|	:string(char length), :int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64
    max(maxValue int or int8 or int16 or int32 or int64 or uint8 or uint16 or uint32 or uint64 or float32 or float64)|	:string(char length), :int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64
    range(minValue, maxValue int or int8 or int16 or int32 or int64 or uint8 or uint16 or uint32 or uint64 or float32 or float64)|	:int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64

    ```
    app.Get("/profile/{name:alphabetical max(255)}", func(ctx iris.Context){
        name := ctx.Params().Get("name")
        // len(name) <=255 否则这个路由将触发 404 Not Found
        // ，此处理程序将不会执行。
    })
    ```
7. 路由中间件
    1. 编写中间件
        - 中间件只是func(ctx iris.Context)的处理程序形式之一，当上一个中间件调用ctx.Next() 时，当前中间件就会执行
        ```
        func before(ctx iris.Context) {
            requestPath := ctx.Path()
            println("Before the mainHandler: " + requestPath)

            ctx.Values().Set("info", requestPath)
            ctx.Next() //执行下一个处理程序，在本例中为主要处理程序。
        }

        func after(ctx iris.Context) {
            println("After the mainHandler")
        }

        func indexHandler(ctx iris.Context) {
            ctx.JSON(iris.Map{
                "message": "hello",
            })
        }

        func mainHandler(ctx iris.Context) {
            println("Inside mainHandler")

            // 从 "before" 处理程序中获取信息。
            info := ctx.Values().GetString("info")

            // 向客户端写一些内容作为响应。
            ctx.HTML("<h1>Response</h1>")
            ctx.HTML("<br/> Info: " + info)

            ctx.Next() // 执行 "after" 中间件
        }
        ```
    2. 使用路由中间件
        - Use 和 Done 应用于当前路由分组和它的子分组，即在调用 Use 或 Done 之前的路由，不会应用该中间件
        ```
        func main() {
            app := iris.New()
            app.Get("/home", indexHandler)
            app.Use(before)
            app.Done(after)
            // app.Use(before) 和 app.Done(after) 或者 app.Get("/", before, mainHandler, after)
            app.Get("/main", mainHandler)
            app.Run(iris.Addr(":8080"))
        }
        ```
    3. 使用全局路由中间件
        - 在路由注册前使用 `app.Use/Done，使用 UseGlobal/DoneGlobal
        ```
        func main() {
            app := iris.New()
            app.Get("/home", indexHandler)
            app.UseGlobal(before)
            app.DoneGlobal(after)
            // app.Use(before) 和 app.Done(after) 或者 app.Get("/", before, mainHandler, after)
            app.Get("/main", mainHandler)
            app.Run(iris.Addr(":8080"))
        }
        ```
    4. 使用 ExecutionRules 去强制执行完成的处理程序，而不需要使用ctx.Next()
        ```
        app.SetExecutionRules(iris.ExecutionRules{
            // Begin: ...
            // Main:  ...
            Done: iris.ExecutionOptions{Force: true},
        })
        ```
8. 错误处理
    - 当出现特定的http错误代码时，可以定义自己的处理程序
    - > [错误处理](https://github.com/kataras/iris/blob/master/_examples/routing/http-errors/main.go)
    ```
    func main() {
        app := iris.New()
        app.OnErrorCode(iris.StatusNotFound, notFound)
        app.OnErrorCode(iris.StatusInternalServerError, internalServerError)
        //为所有“错误”注册一个处理程序
        // 状态代码(kataras/iris/context.StatusCodeNotSuccessful)
        // 默认为 < 200 || >= 400:
        // app.OnAnyErrorCode(handler)
        app.Get("/", index)
        app.Run(iris.Addr(":8080"))
    }

    func notFound(ctx iris.Context) {
        // 当出现 404 时， 渲染模版
        // $views_dir/errors/404.html
        ctx.View("errors/404.html")
    }

    func internalServerError(ctx iris.Context) {
        ctx.WriteString("Oups something went wrong, try again")
    }
    ```
9. 封装路由器
    ```
    // WrapperFunc 用作 WrapRouter 预期输入参数签名
    // 是兼容 net/http 的一个 "low-level" 签名
    // 它用于根据自定义逻辑运行或不运行路由器。
    type WrapperFunc func(w http.ResponseWriter, r *http.Request, router http.HandlerFunc)
    // WrapRouter 在主路由器的顶部添加一个包装器。
    // 通常对于第三方中间件很有用
    // 需要使用像 CORS 这样的中间件包装整个应用程序时。
    func WrapRouter(wrapperFunc WrapperFunc)
    ```
    - 路由器根据 Subdomain，HTTP Method 及其动态 Path 搜索其路由。路由器包装程序可以覆盖该行为并执行自定义代码。
    ```
    app := iris.New()

    otherHandler := func(ctx iris.Context) {
        ctx.Writef("custom router wrapper")
    }

    // 用本地 net/http 处理程序包装路由器。
    app.WarpRouter(func(w http.ResponseWriter, r *http.Request, router http.HandlerFunc) {
        path := r.URL.Path
        // 判断路由前缀
        if strings.HasPrefix(path, "/other") {
            // 获取并释放上下文以便使用它来执行
            ctx := app.ContextPool.Acquire(w, r)
            otherHandler(ctx)
            app.ContextPool.Release(ctx)
            return
        }

        // 否则继续照常服务路由。
        router.ServeHTTP(w, r) 
    )
    ```
10. 覆盖 Context
    - Context 是一个接口。Iris 可以使用 app.ContextPool.Attach 方法 ，将实现附加到Context池本身
    - Do 和 Next 方法，它们仅调用 context.Do 和 context.Next包级函数。
    - 使用应用程序的 ContextPool 将其设置为应用于路由处理程序的 Context 实现
    ```
    import (
        "reflect"

        "github.com/kataras/iris/v12"
        "github.com/kataras/iris/v12/context"
    )

    // 创建你自己的自定义 Context，放入你需要的任何字段。
    type CustomContext struct {
        // 嵌入 `iris.Context` - 
        // 这是完全可选的， 但如果你需要
        // 不覆盖所有 Context 的方法！
        iris.Context
    }

    func (ctx *CustomContext) Do(handlers context.Handlers) {
        context.Do(ctx, handlers)
    }

    func (ctx *CustomContext) Next() {
        context.Next(ctx)
    }

    // 处覆盖想要的任何 Context 方法
    func (ctx *CustomContext) HTML(format string, args ...interface{}) (int, error) {
        ctx.Application().Logger().Infof("Executing .HTML function from CustomContext")

        ctx.ContentType("text/html")
        return ctx.Writef(format, args...)
    }

    func main() {
        app := iris.New()

        app.ContextPool.Attach(func() iris.Context {
            return &CustomContext{
                // 如果你要使用嵌入式 Context,
                // 调用 `context.NewContext` 创建一个：
                Context: context.NewContext(app),
            }
        })

        //  在 ./view/** 目录中的 .html 文件上注册视图引擎
        app.RegisterView(iris.HTML("./views", ".html"))

        // 照常注册路由
        app.Handle("GET", "/", recordWhichContextForExample,
            func(ctx iris.Context) {
                // 使用 覆盖过的 Context 的 HTML 方法。
                ctx.HTML("<h1> Hello from my custom context's HTML! </h1>")
            })

        // 当 CustomContext 本身不直接定义 View 函数时,
        // 这将由 CustomContext.Context 嵌入默认 Context
        app.Handle("GET", "/hi/{firstname:alphabetical}",recordWhichContextForExample,
            func(ctx iris.Context) {
                firstname := ctx.Params().GetString("firstname")

                ctx.ViewData("firstname", firstname)
                ctx.Gzip(true)

                ctx.View("hi.html")
            })

        app.Run(iris.Addr(":8080"))
    }

    func recordWhichContextForExample(ctx iris.Context) {
        ctx.Application().Logger().Infof("(%s) Handler is executing from: '%s'",
            ctx.Path(), reflect.TypeOf(ctx).Elem().Name())

        ctx.Next()
    }
    ```

### fucntion
- Go 函数 不支持 嵌套、重载和默认参数
- 但支持以下特性：
 无需声明原型、不定长度变参、多返回值、命名返回值参数
 匿名函数、闭包
- 定义函数使用关键字 func，且左大括号不能另起一行
- 函数也可以作为一种类型使用

### method
- 通过显示说明receiver来实现与某个类型的组合
- 只能为同一个包中的类型定义方法
- Receiver 可以是类型的值或者指针
- 不存在方法重载
- 可以使用值或指针来调用方法，编译器会自动完成转换
- 从某种意义上来说，方法是函数的语法糖，因为receiver其实就是
方法所接收的第1个参数（Method Value vs. Method Expression） 
- 如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法
- 类型别名不会拥有底层类型所附带的方法
- 方法可以调用结构中的非公开字段

1. 显示说明receiver来实现与某个类型的组合
```
//Animal动物
type Animal struct {
	Name   string
	weight float32
}

//Receiver 值类型
func (a Animal) call() {
	fmt.Printf("Animal %s call \n", a.Name)
}
```
2. Receiver 可以是类型的值或者指针
```
//Receiver 指针类型
func (a *Animal) callExchange() {
	//Receiver可能为nil
	if a == nil {
		fmt.Println("Animal is nil")
		return
	}
	a.Name = "dog"
	fmt.Printf("Animal %s call \n", a.Name)
}
```
3. 不存在方法重载
```
//redeclared in this block
func (a Animal) call(i int) {
    fmt.Printf("Animal %s call %d \n", a.Name, i)
}
```
4. 使用值或指针来调用方法
```
c := Animal{Name: "lion"}
d := &Animal{Name: "lion"}
c.call()
d.call()
// Animal lion call 
// Animal lion call 
```
5. receiver其实就是
方法所接收的第1个参数
```
//SI,定义SI类型的string
type SI string
func (si *SI) print() {
	fmt.Println(*si, si)
}
var si SI = "test"
si.print()
(*SI).print(&si)
// test 0xc000010240
// test 0xc000010240
```